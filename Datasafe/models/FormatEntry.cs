/*
 * Copyright (c) 2020, 2023, Oracle and/or its affiliates. All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

// NOTE: Code generated by OracleSDKGenerator.
// DO NOT EDIT this file manually.


using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;

namespace Oci.DatasafeService.Models
{
    /// <summary>
    /// A format entry is part of a masking format and defines the logic to mask data. A format 
    /// entry can be a basic masking format such as Random Number, or it can be a library masking 
    /// format. If a masking format has more than one format entries, the combined output of all 
    /// the format entries is used for masking. 
    /// 
    /// </summary>
    [JsonConverter(typeof(FormatEntryModelConverter))]
    public class FormatEntry 
    {
        
        
        /// <value>
        /// The description of the format entry.
        /// </value>
        [JsonProperty(PropertyName = "description")]
        public string Description { get; set; }
        
    }

    public class FormatEntryModelConverter : JsonConverter
    {
        private static NLog.Logger logger = NLog.LogManager.GetCurrentClassLogger();
        public override bool CanWrite => false;
        public override bool CanRead => true;
        public override bool CanConvert(System.Type type)
        {
            return type == typeof(FormatEntry);
        }
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            throw new System.InvalidOperationException("Use default serialization.");
        }

        public override object ReadJson(JsonReader reader, System.Type objectType, object existingValue, JsonSerializer serializer)
        {
            var jsonObject = JObject.Load(reader);
            var obj = default(FormatEntry);
            var discriminator = jsonObject["type"].Value<string>();
            switch (discriminator)
            {
                case "RANDOM_STRING":
                    obj = new RandomStringFormatEntry();
                    break;
                case "DETERMINISTIC_SUBSTITUTION":
                    obj = new DeterministicSubstitutionFormatEntry();
                    break;
                case "DETERMINISTIC_ENCRYPTION":
                    obj = new DeterministicEncryptionFormatEntry();
                    break;
                case "RANDOM_DECIMAL_NUMBER":
                    obj = new RandomDecimalNumberFormatEntry();
                    break;
                case "RANDOM_SUBSTITUTION":
                    obj = new RandomSubstitutionFormatEntry();
                    break;
                case "POST_PROCESSING_FUNCTION":
                    obj = new PPFFormatEntry();
                    break;
                case "NULL_VALUE":
                    obj = new NullValueFormatEntry();
                    break;
                case "FIXED_NUMBER":
                    obj = new FixedNumberFormatEntry();
                    break;
                case "REGULAR_EXPRESSION":
                    obj = new RegularExpressionFormatEntry();
                    break;
                case "USER_DEFINED_FUNCTION":
                    obj = new UDFFormatEntry();
                    break;
                case "SHUFFLE":
                    obj = new ShuffleFormatEntry();
                    break;
                case "FIXED_STRING":
                    obj = new FixedStringFormatEntry();
                    break;
                case "TRUNCATE_TABLE":
                    obj = new TruncateTableFormatEntry();
                    break;
                case "LIBRARY_MASKING_FORMAT":
                    obj = new LibraryMaskingFormatEntry();
                    break;
                case "SQL_EXPRESSION":
                    obj = new SQLExpressionFormatEntry();
                    break;
                case "DETERMINISTIC_ENCRYPTION_DATE":
                    obj = new DeterministicEncryptionDateFormatEntry();
                    break;
                case "RANDOM_DIGITS":
                    obj = new RandomDigitsFormatEntry();
                    break;
                case "DELETE_ROWS":
                    obj = new DeleteRowsFormatEntry();
                    break;
                case "SUBSTRING":
                    obj = new SubstringFormatEntry();
                    break;
                case "RANDOM_NUMBER":
                    obj = new RandomNumberFormatEntry();
                    break;
                case "PRESERVE_ORIGINAL_DATA":
                    obj = new PreserveOriginalDataFormatEntry();
                    break;
                case "RANDOM_DATE":
                    obj = new RandomDateFormatEntry();
                    break;
                case "RANDOM_LIST":
                    obj = new RandomListFormatEntry();
                    break;
            }
            if (obj != null)
            {
                serializer.Populate(jsonObject.CreateReader(), obj);
            }
            else
            {
                logger.Warn($"The type {discriminator} is not present under FormatEntry! Returning null value.");
            }
            return obj;
        }
    }
}
